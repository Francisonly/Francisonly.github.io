{"meta":{"title":"Porthub","subtitle":"悟","description":"不能信任那些Terminal或Editor用白底的人😂😂","author":"Francis Zh","url":"https://francisonly.github.io","root":"/"},"pages":[{"title":"about","date":"2019-06-24T09:11:34.000Z","updated":"2019-08-22T03:06:51.646Z","comments":true,"path":"about/index.html","permalink":"https://francisonly.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-06-24T09:08:23.000Z","updated":"2019-08-22T03:06:51.651Z","comments":true,"path":"categories/index.html","permalink":"https://francisonly.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-06-24T09:12:21.000Z","updated":"2019-08-22T03:06:51.651Z","comments":true,"path":"friends/index.html","permalink":"https://francisonly.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-06-24T09:10:47.000Z","updated":"2019-08-22T03:06:51.650Z","comments":true,"path":"tags/index.html","permalink":"https://francisonly.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"String回顾及从JVM分析String常量池问题.md","slug":"String回顾及从JVM分析String常量池","date":"2019-08-26T09:03:04.000Z","updated":"2019-08-26T09:03:41.248Z","comments":true,"path":"2019/08/26/string-hui-gu-ji-cong-jvm-fen-xi-string-chang-liang-chi/","link":"","permalink":"https://francisonly.github.io/2019/08/26/string-hui-gu-ji-cong-jvm-fen-xi-string-chang-liang-chi/","excerpt":"","text":"1、字符串特点​ String 类代表字符串。Java 程序中的所有字符串字面值（如 &quot;abc&quot; ）都作为此类的实例实现。即程序中所有双引号的字符串都是String类的对象，即使没有new关键字。 1.字符串是常量，内容永不可变； 2.正是因为内容不可变，所以字符串可以共享使用,达到节省内存的作用； 3.字符串效果上相当于字符数组char[],但底层是字节数组byte[]。 2、3+1种构造方法​ 1.public String( );创建一个空白字符串，不含有任何内容; 2.public String(char[ ] array);根据字符数组的内容，来创建对应的字符串； 3.public String(byte[ ] array);根据字符数组的内容，来创建对应的字符串； 4.直接创建。 3、常用方法​ 3.1比较方法 地址值比较 ==； 内容比较 equals()，忽律大小写永equalgnoreCase()； equals()注意事项： 1.任何对象都能用object接收； 2、对称性 3、如果比较双方一个常量一个变量，推荐把字符串常量放在前边； String str1 = null; str1.equals(\"abc\"); 报错 空指针异常 ​ 3.2获取相关方法 1.public int length() -长度； 2.public String concat(String str)-拼接; 3.public Char charAt(int index)-获取制定索引位置的字符，索引从0开始; 4.public int indexOf(String str)-查找参数字符串在 本字符串中首次出现的位置，如果没有返回-1； ​ 3.3字符串截取方法 1.public String sunstring(int index)，截取从参数位置一直到字符串末尾，返回新字符串； 2..public String sunstring(int begin,int end),注意左闭右开。 ​ 3.4转换相关方法 1.public char[ ] toCharArray( ) -将当前字符串转换成字符数组作为返回值； 2.public byte[ ] getByte( ) -获得当前字符串的底层字节数组； 3.public String replace(oldster,newstr) ​ 3.5字符串分割方法 1.public String[ ] split(String regex) - 按照参数规则，将字符串分成若干方法。 注意事项：split()方法是一个正则表达式，如果按照英文句点切分，必须写”\\.“。 4、String常量池​ 在讲常量池之前我们先来做个测试： import java.util.Arrays; public class DemoString { public static void main(String[] args) { String str1 = \"abc\"; String str2 = \"abc\"; String str3 = new String(\"abc\"); String str4 = new String(\"abc\"); char[] arr = {'a', 'b', 'c'}; String str5 = new String(arr); String str6 = new String(\"abc\").intern(); System.out.println(\"str1 == str2:\" + (str1 == str2)); System.out.println(\"str1.equals(str2):\" + str1.equals(str2)); System.out.println(\"str1 == str3:\" + (str1 == str3)); System.out.println(\"str1.equals(str3):\" + str1.equals(str3)); System.out.println(\"str3 == str4:\" + (str3 == str4)); System.out.println(\"str3.equals(str4)):\" + (str3.equals(str4))); System.out.println(\"str1 == str5\" + (str1 == str5)); System.out.println(\"str1.equals(str5)\" + str1.equals(str5));//t //System.out.println(str1 == arr);编译错误 不可比较的类型 System.out.println(\"str1.equals(arr):\" + str1.equals(arr)); System.out.println(\"str1.equals(Arrays.toString(arr))\" + str1.equals(Arrays.toString(arr))); System.out.println(Arrays.toString(arr)); System.out.println(\"str1 == str6:\" + (str1 == str6)); System.out.println(\"str3 == str6:\" + (str3 == str6)); System.out.println(\"-------------------\"); String str7 = \"\"; String str8 = \"\"; System.out.println(\"str7 == str8:\" + (str7 == str8)); System.out.println(\"str7.equals(str8):\" + str7.equals(str8)); String str9 = null; String str10 = null; System.out.println(\"str7 == str9:\" + (str7 == str9)); System.out.println(\"str7.equals(str9):\" + str7.equals(str9)); System.out.println(\"str9 == str10:\" + (str9 == str10)); System.out.println(\"str9.equals(str10):\" + str9.equals(str10));//空指针异常 } } str1 == str2:true str1.equals(str2):true str1 == str3:false str1.equals(str3):true str3 == str4:false str3.equals(str4)):true str1 == str5false str1.equals(str5)true str1.equals(arr):false str1.equals(Arrays.toString(arr))false [a, b, c] str1 == str6:true str3 == str6:false ------------------- str7 == str8:true str7.equals(str8):true str7 == str9:false str7.equals(str9):false str9 == str10:true Exception in thread \"main\" java.lang.NullPointerException at DemoString.main(DemoString.java:36) 字符串常量池机制 目的：JVM为了提高性能和减少内存开销，实现数据共享。 1.为字符串开辟一个字符串常量池(存在于方法区); 2.创建字符串常量时，首先判断字符串常量池是否存在该字符串; 3.存在该字符串，返回引用实例，不存在，实例化字符串并放入池中。 注意:直接通过双引号创建的string，就在常量池中。 对于基本类型来说，==是数值的比较； 对于引用类型来说，==是地址值的比较。 ​ 从JVM角度分析： String str1 = “abc”,创建的String str引用放在栈中，在堆中存在一块内存区域-字符串常量池。字符串对象保存在常量池中，不过它保存的也是一个地址值（后面提到的字节数组的地址值）。在堆中会存在byte字节数组来存储”abc”。即JVM在创建”abc”的时候，其实是把它转换为了字节数组，字符串常量池中的对象保存的其实是这个字节数组的地址，字符串对象自身也有一个地址，这个地址值保存在栈中的对象引用str1。在创建String str2 = “abc”的时候,会发现池中已经存在”abc”字节数组的地址，所以这个地址会被重复利用，不会创建新的对象。 对于char[ ] charArray = {‘a’, ‘b’, ‘c’},char[ ] charArray保存的也是一个地址（数组在堆内存的地址），数组存在堆内存。String str3 = new String(charArray);存在new关键字和常量池无关，会把char型数组转换为字节数组。new开辟新的内存创建一个String对象，这个对象保存字节数组的地址。这个对象本身也有一个地址，该地址保存在栈中的对象引用str3。 ​ ​ 关于String intern()方法，即使是new的情况下也会放入常量池。 ​ 关于空字符串””和null，String str7 = “”，开辟了内存，只是没有存储任何字符，String str9 = null，没有开辟内存。 参考字符串的常量池 对String常量池的理解","categories":[],"tags":[]},{"title":"深入理解多态","slug":"深入理解多态","date":"2019-08-05T03:48:37.000Z","updated":"2019-08-26T09:34:41.859Z","comments":true,"path":"2019/08/05/shen-ru-li-jie-duo-tai/","link":"","permalink":"https://francisonly.github.io/2019/08/05/shen-ru-li-jie-duo-tai/","excerpt":"","text":"1、什么是多态1.1 概念 ​ 引用Charlie Calverts对多态的描述——多态性是允许你将父对象设置成为一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。 表现：父类引用指向子类对象。 格式：Fu obj = new Zi ( ); 或者 接口名称 obj = new 实现类名称（）； 1.2 多态的两种形式 ​ 编译时多态： 编译期间决定目标方法 通过重载实现 * 方法名相同，参数不同 ​ 运行时多态： 运行期间决定目标方法 同名同参 通过重写和继承实现 JVM决定目标法方法 1.3 三个前提 继承 重写 父类引用指向子类对象 1.4 作用 ​ 通用角度: 把不同的子类对象当成父类来用（即向上转型），可以屏蔽不同子类对象的差异，写出通用的代码。做出通用的编程，以适应需求的不断变化。特异性角度： 赋值以后，父类型的引用就可以根据当前赋值的子对象之间的差异以不同的方式运作。也就是说父亲的行为像儿子，而不是儿子的行为像父亲。 2、多态中成员变量/方法的访问​ 先说结果，对于访问成员变量和成员方法，多态有自己的一套准则：1、访问成员变量，编译看左，运行看左；2、访问成员方法，编译看左，运行看右（只针对重写了的方法）； 3、访问静态方法，编译看左，运行看左。 总的来说就记住这么一句，多态中只有非静态的成员方法才是编译看父类，而运行时看子类，也即是实际调用的是子类方法。 ​ 例子：花木兰替父从军 1、花木兰替父亲花弧从军。那么这时候花木兰是子类，花弧是父类。 2、花弧有自己的成员属性年龄，姓名，性别。花木兰也有这些属性，但是很明显二者的属性完全不一样。 3、花弧有自己的非静态成员方法‘骑马杀敌’，同样花木兰也遗传了父亲一样的方法‘骑马杀敌’。 4、花弧有自己的非静态成员方法‘骑马杀敌’，同样花木兰也遗传了父亲一样的方法‘骑马杀敌’。 但是，现在花木兰替父从军，女扮男装。这时候相当于父类的引用（花弧这个名字）指向了子类对象（花木兰这个人），那么在其他类（其他的人）中访问子类对象（花木兰这个人）的成员属性（姓名，年龄，性别）时，其实看到的都是花木兰她父亲的名字（花弧）、年龄（60岁）、性别（男）。当访问子类对象（花木兰这个人）的非静态成员方法（骑马打仗）时，其实都是看到花木兰自己运用十八般武艺在骑马打仗。当访问花木兰的静态方法时（自我介绍），花木兰自己都是用她父亲的名字信息在向别人作自我介绍。并且这时候花木兰不能使用自己特有的成员方法‘涂脂抹粉’。—–多态中的向上转型。 那么终于一将功成万骨枯，打仗旗开得胜了，花木兰告别了战争生活。有一天，遇到了自己心爱的男人，这时候爱情的力量将父类对象的引用（花弧这个名字）强制转换为子类对象本来的引用（花木兰这个名字），那么花木兰又从新成为了她自己，这时候她完全是她自己了。名字是花木兰，年龄是28，性别是女，打仗依然那样生猛女汉子，自我介绍则堂堂正正地告诉别人我叫花木兰。OMG！终于，终于可以使用自己特有的成员方法‘涂脂抹粉’了。从此，花木兰完全回到了替父从军前的那个花木兰了。并且和自己心爱的男人幸福的过完了一生。—–多态中的向下转型。注意：向上/下转型一定是在多态这个前提下，向上转型有一个弊端，对象一旦向上转型，就不能调用子类特有方法。解决方案-向下转型，格式：子类 obj = (子类) 父类对象。 package huamulan.tfcj; public class Huahu { int age = 60; String name = \"花弧\"; String sex = \"男\"; void intro(){ System.out.println(\"我叫花弧\"); } void kill(){ System.out.println(\"花弧骑马杀人\"); } } package huamulan.tfcj; public class Huamulan extends Huahu { int age = 20; String name = \"花木兰\"; String sex = \"女\"; void makeUp(){ System.out.println(\"花木兰涂脂抹粉\"); } @Override void kill(){ System.out.println(\"花木兰骑马杀人\"); } } package huamulan.tfcj; public class Test { public static void main (String[] args){ Huahu huamulan = new Huamulan(); //访问成员变量 System.out.println(huamulan.name + huamulan.age + huamulan.sex); //访问骑马杀敌方法 huamulan.kill(); //访问父类特有方法 huamulan.intro(); //访问子类特有方法编译错误，这是因为对象一旦向上转型，就不能调用子类特有方法 // huamulan.makeUp(); System.out.println(\"--------------\"); Huamulan huamulan1 = (Huamulan) huamulan; huamulan1.makeUp(); } } ​ 结果： 花弧60男 花木兰骑马杀人 我叫花弧 -------------- 花木兰涂脂抹粉 3、多态实现机制​ 接下来，我们来看一下jvm是如何识别目标方法的。 刚才我们说到，重载方法的区分在编译阶段已经完成了，那么我们就可以认为在java虚拟机中不存在重载这一概念。因此，重载也可以被称为静态绑定，而重写则被称为动态绑定。在jvm中，我们有5种方法调用的指令，分别是：invokestatic：调用静态方法；invokespecial：调用实例构造方法，私有方法和父类方法，以及使用super关键字调用父类的实例方法或构造器；invokevirtual：调用虚方法(非私有实例方法)；invokeinterface：调用接口方法，在运行时再确定一个实现此接口的对象；invokedynamic：在运行时动态解析出调用点限定符所引用的方法之后，调用该方法(jdk1.8lamada表达式)； 这里，我们简单介绍一下这几种指令，对于invokestatic指令和invokespecial指令而言，java虚拟机能够直接识别目标方法，也就是我们所说的静态绑定。invokevirtual和invokeinterface指令则需要在执行的过程中才能找到目标方法，也就是我们所说的动态绑定。只要能被invokestatic和invokespecial指令调用的方法，都可以在类加载过程中的解析阶段中确定唯一的调用版本，符合这个条件的方法有静态方法、私有方法、实例构造器和父类方法四种，它们在类加载过程中的解析阶段就会将符号引用解析为该方法的直接引用。这些方法可以称为非虚方法（也就是不涉及到多态的方法），与之对应的就是虚方法。虚方法需要在运行阶段才能确定目标方法的直接引用。 总结一下静态/动态绑定和虚/非虚方法的概念： 1、静态绑定：在程序执行之前就已经被绑定、也就是说再编译阶段就已经知道这个方法是属于哪个类的方法。 1.private修饰的方法，不能被子类调用 2. 被final修饰的方法（可以调用，不能重写） 3.被static修饰的方法 2、动态绑定：在运行过程中根据调用者的动态类型来识别目标方法的情况。 3、动态绑定中，我们会记录方法对应的实际引用的地址，也可以理解为索引值，这里我们把它叫做方法表。方法表使用了数组的数据结构，每个数组元素指向了当前类以及其祖先类中非私有的实例方法。这个数据结构，便是java虚拟机实现动态绑定的关键所在。 ​ 4、虚/非虚方法：除了静态方法之外，声明为final或者private的实例方法是非虚方法。其它（其他非private方法）实例方法都是虚方法。 静态方法也是非虚方法，被重写的都是虚方法。 4、一个经典例子（一）相关类 class A { public String show(D obj){ return (\"A and D\"); } public String show(A obj){ return (\"A and A\"); } } class B extends A{ public String show(B obj){ return (\"B and B\"); } public String show(A obj){ return (\"B and A\"); } } class C extends B{} class D extends B{} （二）问题：以下输出结果是什么？ A a1 = new A(); ​ A a2 = new B(); ​ B b = new B(); ​ C c = new C(); ​ D d = new D(); ​ System.out.println(a1.show(b)); ① ​ System.out.println(a1.show(c)); ② ​ System.out.println(a1.show(d)); ③ ​ System.out.println(a2.show(b)); ④ ​ System.out.println(a2.show(c)); ⑤ ​ System.out.println(a2.show(d)); ⑥ ​ System.out.println(b.show(b)); ⑦ ​ System.out.println(b.show(c)); ⑧ ​ System.out.println(b.show(d)); ⑨ （三）答案 ① A and A ② A and A ③ A and D ④ B and A ⑤ B and A ⑥ A and D ⑦ B and B ⑧ B and B ⑨ A and D （四）分析 ​ 实际上这里涉及方法调用的优先问题 ，优先级由高到低依次为：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。 比如④，a2.show(b)，a2是一个引用变量，类型为A，则this为a2，b是B的一个实例，于是它到类A里面找show(B obj)方法，没有找到，于是到A的super(超类)找，而A没有超类，因此转到第三优先级this.show((super)O)，this仍然是a2，这里O为B，(super)O即(super)B即A，因此它到类A里面找show(A obj)的方法，类A有这个方法，但是由于a2引用的是类B的一个对象，B覆盖了A的show(A obj)方法，因此最终锁定到类B的show(A obj)，输出为”B and A”。 再比如⑧，b.show(c)，b是一个引用变量，类型为B，则this为b，c是C的一个实例，于是它到类B找show(C obj)方法，没有找到，转而到B的超类A里面找，A里面也没有，因此也转到第三优先级this.show((super)O)，this为b，O为C，(super)O即(super)C即B，因此它到B里面找show(B obj)方法，找到了，由于b引用的是类B的一个对象，因此直接锁定到类B的show(B obj)，输出为”B and B”。 当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。还是拿a2.show(b)来说吧。 a2是一个引用变量，类型为A，它引用的是B的一个对象，因此这句话的意思是由B来决定调用的是哪个方法。因此应该调用B的show(B obj)从而输出”B and B”才对。但是为什么跟前面的分析得到的结果不相符呢？！问题在于我们不要忽略了蓝色字体的后半部分，那里特别指明：这个被调用的方法必须是在超类中定义过的，也就是被子类覆盖的方法。B里面的show(B obj)在超类A中有定义吗？没有！那就更谈不上被覆盖了。实际上这句话隐藏了一条信息：它仍然是按照方法调用的优先级来确定的。它在类A中找到了show(A obj)，如果子类B没有覆盖show(A obj)方法，那么它就调用A的show(A obj)（由于B继承A，虽然没有覆盖这个方法，但从超类A那里继承了这个方法，从某种意义上说，还是由B确定调用的方法，只是方法是在A中实现而已）；现在子类B覆盖了show(A obj)，因此它最终锁定到B的show(A obj)。这就是那句话的意义所在，到这里，我们可以清晰的理解Java的多态性了。 参考资料Java多态性 的详细举例说明 你知道多态的实现机制吗?是时候好好回顾一下了！ 多态：JVM是如何进行方法调用的 细说JVM（虚拟机实现多态） 谈谈对Java多态的理解","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://francisonly.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://francisonly.github.io/tags/Java/"}]},{"title":"Java集合系列03-Set","slug":"Java集合系列03-Set","date":"2019-07-04T12:59:22.000Z","updated":"2019-08-22T03:07:43.868Z","comments":true,"path":"2019/07/04/java-ji-he-xi-lie-03-set/","link":"","permalink":"https://francisonly.github.io/2019/07/04/java-ji-he-xi-lie-03-set/","excerpt":"","text":"​ Set接口的特点：1、不允许元素重复；2、无序的集合。 1、HashSet​ HashSet特点：1、不允许存储重复元素； 2、没有索引，没有带索引的方法，不能使用普通的for循环； 3、无序集合，存储取出顺序可能不同； 4、底层是哈希表（查询速度非常快)； 下面用一个demo展示set的无序性： package demo.hashset; import java.util.HashSet; import java.util.Iterator; import java.util.Set; public class DemoHashSet { public static void main(String[] args) { Set&lt;String> set= new HashSet&lt;>(); set.add(\"zhou\"); set.add(\"wu\"); set.add(\"zeng\"); System.out.println(\"使用Iterator遍历\"); Iterator iterator = set.iterator(); while (iterator.hasNext()){ System.out.print(iterator.next()+\" \"); } System.out.println(\"\\n使用增强for循环遍历\"); for(String s : set){ System.out.print(s+\" \"); } } } 打印结果： 使用Iterator遍历 zeng zhou wu 使用增强for循环遍历 zeng zhou wu 2、哈希表​ 在学习哈希表之前我们先来学习一下哈希值。哈希值是一个十进制的整数，由系统随机给出，是对象的逻辑地址。int hasCode()返回对象的哈希码值。 ​ 哈希表——HashSet存储数据的结构。如果链表的结构超过了8位，那么就会把链表转换成红黑树 。 Java1.8之前：哈希表=数组+链表；Java1.8之后：哈希表=数组+链表/红黑树。特点：查询速度快。 先把元素根据哈希值进行分组，将相同哈希值的元素用链表连接起来 3、Set集合不重复原理​ Set集合在调用add()方法时，会先调用元素的hasCode()和equals()方法，判断元素是否重复。(1)set.add();(2)object.hasCode();(3)判断是否哈希冲突（哈希值相同） (3.1）哈希冲突 (3.1.1)调用equals方法判断是否相同{ (3.1.1.1)true 抛弃，不存储 (3.1.1.2)false 存储 (3.2)哈希值不同 存储在不同的索引处 以第2小节中的图为例说明： 三个字符串”abc“、”重地“和”通话“。重地和通话的的哈希值相同，与abc的哈希值不同。首先添加abc，调用它的hasCode()方法，没有产生哈希冲突，就将abc放在哈希表的某个索引处。 然后，添加”重地”，没有产生哈希冲突，就将abc放在哈希表的某个索引处。 最后，添加”通话“，产生哈希冲突，调用equals()方法，判断“重地”和“通话”是否相同，显然不同，所以就用链表将二者连接在了同一个索引处。 前提：重写hasCode()和equals()方法。 Demo: 创建一个Person类，在HashSet中添加三个Person类的对象，然后分别在四种情况下打印结果遍历打印结果。 重写toString()方法 重写hasCode()方法 重写equals()方法 打印结果 Case1 ✔️ ✖️ ✖️ demo.hashset2.Person@2752f6e2demo.hashset2.Person@e580929demo.hashset2.Person@6b71769e Case2 ✔️ ✔️ ✖️ name:qian age:20name:zhao age:18name:zhao age:18 Case3 ✔️ ✖️ ✔️ name:qian age:20name:zhao age:18name:zhao age:18 Case4 ✔️ ✔️ ✔️ name:zhao age:18name:qian age:20 package demo.hashset2; public class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public int hashCode() { return name.hashCode() + age; } @Override public boolean equals(Object obj) { if (obj instanceof Person) { Person p = (Person) obj; return this.name.equals(p.name) &amp;&amp; this.age == p.age; } else { return false; } } @Override public String toString() { return (\"name:\" + name + \" age:\" +age); } } package demo.hashset2; import java.util.HashSet; public class DemoHashSet2 { public static void main(String[] args) { Person p1 = new Person(\"zhao\", 18); Person p2 = new Person(\"qian\", 20); Person p3 = new Person(\"zhao\", 18); HashSet set = new HashSet(); set.add(p1); set.add(p2); set.add(p3); /*没有重写toStrign()、hasCode()和equals()的打印结果： *demo.hashset2.Person@2752f6e2 *demo.hashset2.Person@e580929 *demo.hashset2.Person@6b71769e **/ /*重写toString方法的打印结果 *name:qian age:20 *name:zhao age:18 *name:zhao age:18 **/ /*重写hasCode()没有重写hasCode()方法的打印结果： *name:zhao age:18 *name:zhao age:18 *name:qian age:20 **/ /*重写equals()方法没有重写hasCode()方法 *name:qian age:20 *name:zhao age:18 *name:zhao age:18 **/ /*name:zhao age:18 *name:qian age:20 **/ for (Object o : set) { System.out.println(o); } } } ​","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://francisonly.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://francisonly.github.io/tags/Java/"},{"name":"集合","slug":"集合","permalink":"https://francisonly.github.io/tags/集合/"}]},{"title":"Java知识点系列01-重载和重写","slug":"Java知识点系列01-重载和重写","date":"2019-07-01T04:26:42.000Z","updated":"2019-08-22T13:40:31.142Z","comments":true,"path":"2019/07/01/java-zhi-shi-dian-xi-lie-01-chong-zai-he-chong-xie/","link":"","permalink":"https://francisonly.github.io/2019/07/01/java-zhi-shi-dian-xi-lie-01-chong-zai-he-chong-xie/","excerpt":"","text":"1、重载 Overload 定义：重载，简单说，就是函数或者方法有相同的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。 适用场景：有多个功能类似的方法，但是参数列表不一样。 优点：只需要记住一个方法名，实现类似的功能。 因素： 1、参数个数不同；eg. f(int a, int b)与 f(int a,int b, int c) ​ 2、参数类型不同; eg.f(int a)与f(double a); ​ 3、参数类型顺序不同；eg.f(int a, double b)与f(double a, int b; ​ 4、与返回值和参数名称无关 特点：1、在使用重载时只能通过相同的方法名、不同的参数形式来实现。 2、不能通过访问权限、返回类型和抛出的异常进行重载。 3、方法的异常类型和数目不会对重载造成影响。 Demo : ​ 有三个方法，分别是sumTwo(int a, int b)，返回两个int类型数据的和, sumThree(int a, int b,int c),返回三个int类型数据的和， sumTwoDouble(double a, double b)，返回两个double 类型的数据的和。三个方法功能类似，参数列表不同，采用重载，改为同一个方法名sum。那么我们怎么知道每次调用的是三个方法中哪个方法呢？ ​ ——根据输入的参数。 /** * @project DemoOverload * @date 2019/6/30 */ public class DemoOverload { public static void main(String[] args) { System.out.println(\"原来的sunTwo方法，结果是\" + sum(10, 20)); System.out.println(\"原来的sunThree方法，结果是\" + sum(+10, 20, 30)); System.out.println(\"原来的sunTwoDouble方法，结果是\" + sum(10.0, 20.0)); } public static int sum(int a, int b) { return a + b; } public static int sum(int a, int b, int c) { return a + b + c; } public static double sum(double a, double b) { return a + b; } /*public static int sumTwo(int a, int b) { return a+b; } public static int sumThree(int a, int b,int c) { return a+b+c; } public static double sumTwoDouble(double a, double b) { return a+b; }*/ } 打印结果： 原来的sunTwo方法，结果是30 原来的sunThree方法，结果是60 原来的sunTwoDouble方法，结果是30.0 2、重写 Override 定义：子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！ 优点：子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。 注意事项：1、父子类方法的名称、参数都相同。 ​ 2、@Override写在前面，检查是否正确重写，也可以不写； ​ 3、子类方法的返回值必须小于等于父类返回值范围（public&gt;protected&gt;default&gt;private）； ​ 4、子类方法的权限（修饰符）必须大于等于父类权限； ​ 5、重写的方法所抛出的异常必须和被重写方法的所抛出的异常一致，或者是其子类； ​ 6、被重写的方法不能为private，否则在其子类中只是新定义了一个方法，并没有对其进行重写； ​ 7、静态方法不能被重写为非静态的方法（会编译出错）。 Demo：定义一个抽象类Animal和一个抽象方法eat。 /** * @project 抽象类Animal * @date 2019/6/30 */ public abstract class Animal { public abstract void eat(); } Cat类继承Animal类，并对其抽象方法eat进行重写（继承抽象类必须重写父类的抽象方法）。 /** * @project: Cat类 * @data: 19/07/01 */ public class Cat extends Animal { @Override public void eat() { System.out.println(\"猫吃鱼\"); } public static void main(String[] args) { Cat cat = new Cat(); cat.eat(); } } 3、重载和重写区别重载：函数名一样，参数列表不同；重写：函数名和参数 都一样。 *本质上的不同在于，因为函数有相似的功能所以才用重载。正是因为我们希望子类方法和父类方法的反应不同，才采用了重写。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://francisonly.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://francisonly.github.io/tags/Java/"},{"name":"Java知识点","slug":"Java知识点","permalink":"https://francisonly.github.io/tags/Java知识点/"}]},{"title":"Java集合系列01-总体框架","slug":"Java集合系列01-总体框架","date":"2019-06-23T08:35:19.000Z","updated":"2019-08-22T03:07:43.864Z","comments":true,"path":"2019/06/23/java-ji-he-xi-lie-01-zong-ti-kuang-jia/","link":"","permalink":"https://francisonly.github.io/2019/06/23/java-ji-he-xi-lie-01-zong-ti-kuang-jia/","excerpt":"","text":"1、总体框架​ Java集合是java提供的工具包，包含了常用的数据结构：集合、链表、队列、栈、数组、映射等。Java集合工具包位置是java.util.* Java集合主要可以划分为4个部分：List列表、Set集合、Map映射、工具类(Iterator迭代器、Enumeration枚举类、Arrays和Collections)、。 Java集合工具包框架图(如下)： 2、容器分类Java容器可分为两大类： Collection List ArrayList LinkedList Vector Set HashSet LinkedHashSet TreeSet Map HashMap LinkedHashMap TreeMap ConcurrentHashMap Hashtable为了更清晰的表示下面用思维导图进行说明： 参考资料: Java 集合系列01之 总体框架 Collection总览","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://francisonly.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://francisonly.github.io/tags/Java/"},{"name":"集合","slug":"集合","permalink":"https://francisonly.github.io/tags/集合/"}]},{"title":"Java集合系列02-List","slug":"Java集合系列02-List","date":"2019-06-23T08:35:19.000Z","updated":"2019-08-22T03:07:43.866Z","comments":true,"path":"2019/06/23/java-ji-he-xi-lie-02-list/","link":"","permalink":"https://francisonly.github.io/2019/06/23/java-ji-he-xi-lie-02-list/","excerpt":"","text":"​ List是一个继承于Collection的接口，即List是集合中的一种。List是有序的队列，List中的每一个元素都有一个索引；第一个元素的索引值是0，往后的元素的索引值依次+1。和Set不同，List中允许有重复的元素。 关于API方面。既然List是继承于Collection接口，它自然就包含了Collection中的全部函数接口；由于List是有序队列，它也额外的有自己的API接口。主要有“添加、删除、获取、修改指定位置的元素”、“获取List中的子队列”等。 1、 ArrayList​ ArrayList 继承了AbstractList，实现了List。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。 ArrayList是基于动态数组实现的，在增删时候，需要数组的拷贝复制。 ArrayList的默认初始化容量是10，每次扩容时候增加原先容量的一半，也就是变为原来的1.5倍 删除元素时不会减少容量，若希望减少容量则调用trimToSize() 它不是线程安全的。它能存放null值。 下面通过一个demo来学习如何使用ArrayList的常用API。 import java.util.ArrayList; import java.util.Iterator; public class arrayListDemo { public static void main(String[] args) { ArrayList al = new ArrayList(); //增 add（） al.add(\"周\"); al.add(\"吴\"); al.add(\"郑\"); al.add(\"王\"); System.out.println(\"add 测试\"); for(int i = 0; i &lt; al.size(); i++) { System.out.print(al.get(i) + \" \"); } //删 remove() System.out.println(\"\\nremove 测试\");//\\nd的使用 al.remove(0); for(int i = 0; i &lt; al.size(); i++) { System.out.print(al.get(i) + \" \"); } // 插入 add（index，objece）；改 set（） System.out.println(\"\\n插入 测试\"); al.add(0,\"周\"); for(int i = 0; i &lt; al.size(); i++) { System.out.print(al.get(i) + \" \"); } System.out.println(\"\\nset 测试\"); al.set(0, \"王\"); for(int i = 0; i &lt; al.size(); i++) { System.out.print((al.get(i) + \" \")); } //查 get() System.out.println(\"\\nget 测试\"); al.get(0); System.out.print(al.get(0)); //遍历1 随机访问，通过索引值去遍历 ；上面已用到 //遍历2 Iteratir System.out.println(\"\\niterator 测试\"); Iterator iterator = al.iterator(); while(iterator.hasNext()) { System.out.print(iterator.next() + \" \"); } //遍历3 增强for循环 System.out.println(\"\\n增强for循环测试\"); for(Object o : al) { System.out.print(o + \" \"); } //isEmpty();contains() System.out.println(\"\\nisEmpty()测试\"); System.out.print(al.isEmpty()); System.out.println(\"\\nisContains()测试\"); System.out.print(al.contains(\"周\")); //toArray() System.out.println(\"\\ntoArray()测试\"); Object[] oArray = al.toArray(); for(int i = 0;i &lt; oArray.length; i++) { System.out.print(oArray[i]); } } } ​ //运行结果 add 测试 周 吴 郑 王 remove 测试 吴 郑 王 插入 测试 周 吴 郑 王 set 测试 王 吴 郑 王 get 测试 王 iterator 测试 王 吴 郑 王 增强for循环测试 王 吴 郑 王 isEmpty()测试 false isContains()测试 false toArray()测试 王吴郑王 2、Vector​ Vector是矢量队列，支持相关的添加、删除、遍历等功能，提供了随机访问的功能。Vector的底层也是数组，与ArrayList最大的区别就是；同步（线程安全）。Vector是同步的，如果想要ArrayList实现同步，可以使用Collections的方法：List list = Collections.synchronizedList(new ArrayList(…))就可以实现同步了。ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍。 3、LinkedList​ LinkedList的底层是双向链表，它的顺序访问会非常高效，而随机访问效率比较低。它可以被当作堆栈、队列或双端队列进行操作。但是LinkedList也实现了List接口，也就是说它实现了get(int location)、remove(int location)等根据索引值来获取、删除节点的函数。LinkedList是如何实现List的这些接口的，如何将“双向链表和索引值联系起来的”？ 实际原理非常简单，它就是通过一个计数索引值来实现的。例如，当我们调用get(int location)时，首先会比较“location”和“双向链表长度的1/2”；若前者大，则从链表头开始往后查找，直到location位置；否则，从链表末尾开始先前查找，直到location位置。下面通过一个demo来学习如何使用ArrayList的常用API。 import java.util.*; public class linkedListdemo { public static void main(String[] args) { LinkedList ll = new LinkedList(); ll.add(2); ll.add(3); //独有的addFirst和addLast方法 ll.addFirst(1); ll.addLast(4); //遍历1 iterrator Iterator iterator = ll.iterator(); while(iterator.hasNext()) { System.out.print(iterator.next()+\" \"); } System.out.println(); //遍历2增强型for循环 for(Object o : ll) { System.out.print(o+\" \"); } } } //打印结果 1 2 3 4 1 2 3 4 4、List总结 类 数据结构 线程 适用场景 ArrayList 数组 不安全 随机访问 LinkedList 双链表 不安全 快速插入、删除元素 Vector 数组 安全 List可能同时被多个线程操作 ​ LinkedList和ArrayList性能差异分析：通过add(int index, E element)向LinkedList插入元素时。先是在双向链表中找到要插入节点的位置index；找到之后，再插入一个新节点。双向链表查找index位置的节点时，有一个加速动作：若index &lt; 双向链表长度的1/2，则从前向后查找; 否则，从后向前查找ArrayList的add(int index, E element)函数会移动index之后所有元素.通过get(int index)获取ArrayList第index个元素时。直接返回数组中index位置的元素，而不需要像LinkedList一样进行查找。 ArrayList增删慢不是绝对的(在数量大的情况下，已测试)：如果增加元素一直是使用add()(增加到末尾)的话，那是ArrayList要快一直删除末尾的元素也是ArrayList要快【不用复制移动位置】至于如果删除的是中间的位置的话，还是ArrayList要快！但一般来说：增删多还是用LinkedList，因为上面的情况是极端的 参考资料： List集合就这么简单【源码剖析】 Java 集合系列03之 ArrayList详细介绍(源码解析和使用示例","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://francisonly.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://francisonly.github.io/tags/Java/"},{"name":"集合","slug":"集合","permalink":"https://francisonly.github.io/tags/集合/"}]},{"title":"Java集合系列目录","slug":"Java集合系列目录","date":"2019-06-23T08:35:19.000Z","updated":"2019-08-22T03:07:43.869Z","comments":true,"path":"2019/06/23/java-ji-he-xi-lie-mu-lu/","link":"","permalink":"https://francisonly.github.io/2019/06/23/java-ji-he-xi-lie-mu-lu/","excerpt":"","text":"​ 好记性不如烂博客，写java集合系列文章的目的一方面自己学习整理回顾总结，另一方面如有不当之处希望能得到大家的的批评指正。写技术文章前参考学习了很多的博客、视频，在此谢谢这些乐于分享的创作者们，我也希望参与进来，发扬这种开源分享的精神，能帮助到新人就更好了。在无止境的知识面前，永远都是新人～ Java集合系列01-总体框架 Java集合系列02-List Java集合系列03-set","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://francisonly.github.io/categories/Java基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://francisonly.github.io/tags/Java/"},{"name":"集合","slug":"集合","permalink":"https://francisonly.github.io/tags/集合/"}]},{"title":"1、ns3系列-抽象概念","slug":"ns3系列01-抽象概念","date":"2019-06-06T11:30:13.000Z","updated":"2019-08-22T03:07:43.875Z","comments":true,"path":"2019/06/06/ns3-xi-lie-01-chou-xiang-gai-nian/","link":"","permalink":"https://francisonly.github.io/2019/06/06/ns3-xi-lie-01-chou-xiang-gai-nian/","excerpt":"","text":"1.1节点​ 在因特网术语中，任何一台连接到网络的计算设备被称为主机，亦称为终端。 ns -3是一个网络模拟器，而非一个专门的因特网模拟器，为此我们避开术语“主机”，因为这个词太容易让人联想到因特网和及其相关协议。因此，我们选用了一个来源于图论，在其他网络模拟器中亦广泛使用的术语：节点。 ​ ns-3中基本计算设备被抽象为节点。节点由C++中的Node类来描述。Node类提供了用于管理仿真器中网络组件表示的各种方法。 ​ 你应该将节点设想为一台可以添加各种功能的计算机。为了使一台计算机有效地工作，我们可以给它添加应用程序，协议栈，外设卡及驱动程序等。NS3采用了与此相同的模型。 1.2应用程序​ 计算机软件通常可分为两大类： 系统软件和应用软件。系统软件根据计算模型配置和管理计算机中的各种资源，例如内存，处理器周期，硬盘，网络等。系统软件通常并不直接使用这些资源来完成用户任务。用户往往需要运行应用程序来完成一些特定的任务，而应用程序需要使用由系统软件控制的资源。 ​ 通常，系统软件和应用软件的界线表现为特权级的变化，而这种变化是通过操作系统的自陷功能（operating system traps）来实现的。在ns-3中并没有真正的操作系统的概念，更没有特权级别或者系统调用的概念。然而，我们有应用程序的概念。正如“现实世界”中在计算机上运行应用程序以执行各种任务一样，ns-3仿真环境中的应用程序在节点上运行来驱动模拟过程。 ​ 在ns-3中，需要被仿真的用户程序被抽象为应用。应用在C++中用Application类来描述。这个类提供了管理仿真时用户层应用的各种方法。开发者应当用面向对象的方法自定义和创建新的应用。在本教程中，我们会使用Application类的实例：UdpEchoClientApplication 和UdpEchoServerApplication。也许你已经猜到了，这些应用程序包含了一个client/server应用来发送和回应仿真网络中的数据包。 1.3信道​ 在现实世界中，人们可以把计算机连接到网络上。通常我们把网络中数据流流过的媒介称为信道。当你把以太网线插入到墙壁上的插孔时，你正通过信道将计算机与以太网连接。在ns-3的模拟环境中，你可以把节点连接到代表数据交换信道的对象上。在这里，基本的通信子网这一抽象概念被称为信道，在C++中用Channel类来描述。 ​ Channel类提供了管理通信子网对象和把节点连接至它们的各种方法。信道类同样可以由开发者以面向对象的方法自定义。一个信道实例可以模拟一条简单的线缆（wire），也可以模拟一个复杂的巨型以太网交换机，甚至无线网络中充满障碍物的三维空间。 ​ 我们在本教程中将使用几个信道模型的实例，包括：CsmaChannel, PointToPointChannel和WifiChannel。举例来说，CsmaChannel信道模拟了用于一个可以实现载波侦听多路访问通信子网中的媒介。这个信道具有和以太网相似的功能。 1.4网络设备​ 以前，如果想把一台计算机连接到网络上，你就必须买一根特定的网络线缆，并在你的计算机上安装称为外设卡的硬件设备。能够实现网络功能的外接卡被称为网络接口卡（网卡）。现在大多数计算机出厂时已经配置了网卡，所以用户看不到这些的模块。 ​ 一张网卡如果缺少控制硬件的软件驱动是不能工作的。在Unix（或者Linux）系统中，外围硬件被划为 “设备”**。设备通过驱动程序来控制，而网卡通过网卡驱动程序来控制。在Unix和Linux系统中，网卡被称为像eth0这样的名字。 ​ 在ns-3中，网络设备这一抽象概念相当于硬件设备和软件驱动的总和。NS3仿真环境中，网络设备相当于安装在节点上，使得节点通过信道和其他节点通信。像真实的计算机一样，一个节点可以通过多个网络设备同时连接到多条信道上。 ​ 网络设备由C++中的NetDevice类来描述。NetDevice类提供了管理连接其他节点和信道对象的各种方法，并且允许开发者以面向对象的方法来自定义。我们在本教程中将使用几个特定的网络设备的实例，它们分别是CsmaNetDevice, PointToPointNetDevice, 和 WifiNetDevice。正如以太网卡被设计成在以太网中工作一样，CsmaNetDevice被设计成在csma信道中工作，而PointToPointNetDevice 在PointToPoint信道中工作，WifiNetNevice在wifi信道中工作。 1.5拓扑生成器​ 以前，如果想把一台计算机连接到网络上，你就必须买一根特定的网络线缆，并在你的计算机上安装称为外设卡的硬件设备。能够实现网络功能的外接卡被称为网络接口卡（网卡）。现在大多数计算机出厂时已经配置了网卡，所以用户看不到这些的模块。 ​ 一张网卡如果缺少控制硬件的软件驱动是不能工作的。在Unix（或者Linux）系统中，外围硬件被划为 “设备”**。设备通过驱动程序来控制，而网卡通过网卡驱动程序来控制。在Unix和Linux系统中，网卡被称为像eth0这样的名字。 ​ 在ns-3中，网络设备这一抽象概念相当于硬件设备和软件驱动的总和。NS3仿真环境中，网络设备相当于安装在节点上，使得节点通过信道和其他节点通信。像真实的计算机一样，一个节点可以通过多个网络设备同时连接到多条信道上。 ​ 网络设备由C++中的NetDevice类来描述。NetDevice类提供了管理连接其他节点和信道对象的各种方法，并且允许开发者以面向对象的方法来自定义。我们在本教程中将使用几个特定的网络设备的实例，它们分别是CsmaNetDevice, PointToPointNetDevice, 和 WifiNetDevice。正如以太网卡被设计成在以太网中工作一样，CsmaNetDevice被设计成在csma信道中工作，而PointToPointNetDevice 在PointToPoint信道中工作，WifiNetNevice在wifi信道中工作。","categories":[{"name":"ns3从0开始","slug":"ns3从0开始","permalink":"https://francisonly.github.io/categories/ns3从0开始/"}],"tags":[{"name":"ns3","slug":"ns3","permalink":"https://francisonly.github.io/tags/ns3/"}]}]}